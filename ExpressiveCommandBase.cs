using System;
using System.Collections.Generic;
using System.Data;
using System.Diagnostics.Contracts;
using System.Linq;
using System.Threading.Tasks;
using System.Threading.Tasks.Dataflow;
// ReSharper disable MemberCanBeProtected.Global
// ReSharper disable MemberCanBePrivate.Global
// ReSharper disable UnusedMember.Global
// ReSharper disable AutoPropertyCanBeMadeGetOnly.Global

namespace Open.Database.Extensions
{
	/// <summary>
	/// Base class for developing expressive commands.
	/// Includes methods for use with IDbConnection and IDbCommand types.
	/// </summary>
	/// <typeparam name="TConnection">The type of the connection to be used.</typeparam>
	/// <typeparam name="TCommand">The type of the commands generated by the connection.</typeparam>
	/// <typeparam name="TDbType">The DB type enum to use for parameters.</typeparam>
	/// <typeparam name="TThis">The type of this class in order to facilitate proper expressive notation.</typeparam>
	public abstract partial class ExpressiveCommandBase<TConnection, TCommand, TDbType, TThis>
		where TConnection : class, IDbConnection
		where TCommand : class, IDbCommand
		where TDbType : struct
		where TThis : ExpressiveCommandBase<TConnection, TCommand, TDbType, TThis>
	{
		/// <summary>
		/// The connection factory to use to generate connections and commands.
		/// </summary>
		protected readonly IDbConnectionFactory<TConnection> ConnectionFactory;

		/// <summary>
		/// The connection to execute commands on if not using a connection factory.
		/// </summary>
		protected readonly TConnection Connection;

		/// <summary>
		/// The transaction to execute commands on if not using a connection factory.
		/// </summary>
		protected readonly IDbTransaction Transaction;

		ExpressiveCommandBase(
			CommandType type,
			string command,
			IEnumerable<Param> @params)
		{
			Type = type;
			Command = command ?? throw new ArgumentNullException(nameof(command));
			Params = @params?.ToList() ?? new List<Param>();
			Timeout = CommandTimeout.DEFAULT_SECONDS;
		}

		/// <param name="connFactory">The factory to generate connections from.</param>
		/// <param name="type">The command type>.</param>
		/// <param name="command">The SQL command.</param>
		/// <param name="params">The list of params</param>
		protected ExpressiveCommandBase(
			IDbConnectionFactory<TConnection> connFactory,
			CommandType type,
			string command,
			IEnumerable<Param> @params)
			: this(type, command, @params)
		{
			ConnectionFactory = connFactory ?? throw new ArgumentNullException(nameof(connFactory));
			Contract.EndContractBlock();
		}

		/// <param name="connection">The connection to execute the command on.</param>
		/// <param name="transaction">The optional transaction to execute the command on.</param>
		/// <param name="type">The command type>.</param>
		/// <param name="command">The SQL command.</param>
		/// <param name="params">The list of params</param>
		protected ExpressiveCommandBase(
			TConnection connection,
			IDbTransaction transaction,
			CommandType type,
			string command,
			IEnumerable<Param> @params)
			: this(type, command, @params)
		{
			Connection = connection ?? throw new ArgumentNullException(nameof(connection));
			Contract.EndContractBlock();
			Transaction = transaction;
		}

		/// <summary>
		/// The command text or procedure name to use.
		/// </summary>
		public string Command { get; set; }

		/// <summary>
		/// The command type.
		/// </summary>
		public CommandType Type { get; set; }

		/// <summary>
		/// The list of params to apply to the command before execution.
		/// </summary>
		public List<Param> Params { get; protected set; }

		/// <summary>
		/// The command timeout value.
		/// </summary>
		public ushort Timeout { get; set; }

		/// <summary>
		/// Adds a parameter to the params list.
		/// </summary>
		/// <param name="name">The name of the parameter.</param>
		/// <param name="value">The value of the parameter.</param>
		/// <param name="type">The database type of the parameter.</param>
		/// <returns>This instance for use in method chaining.</returns>
		public TThis AddParam(string name, object value, TDbType type)
		{
			if (name == null) throw new ArgumentNullException(nameof(name));
			else if (string.IsNullOrWhiteSpace(name))
				throw new ArgumentException("Parameter names cannot be empty or white space.", nameof(name));
			Contract.EndContractBlock();

			Params.Add(new Param
			{
				Name = name,
				Value = value,
				Type = type
			});

			return (TThis)this;
		}

		/// <summary>
		/// Adds a parameter to the params list.
		/// </summary>
		/// <param name="name">The name of the parameter.</param>
		/// <param name="value">The value of the parameter.</param>
		/// <returns>This instance for use in method chaining.</returns>
		public TThis AddParam(string name, object value)
		{
			if (name == null) throw new ArgumentNullException(nameof(name));
			else if (string.IsNullOrWhiteSpace(name))
				throw new ArgumentException("Parameter names cannot be empty or white space.", nameof(name));
			Contract.EndContractBlock();

			Params.Add(new Param
			{
				Name = name,
				Value = value ?? DBNull.Value
			});
			return (TThis)this;
		}


		/// <summary>
		/// Adds a parameter to the params list.
		/// </summary>
		/// <param name="name">The name of the parameter.</param>
		/// <param name="value">The value of the parameter.</param>
		/// <param name="type">The database type of the parameter.</param>
		/// <returns>This instance for use in method chaining.</returns>
		public TThis AddParam<T>(string name, T? value, TDbType type)
			where T : struct
		{
			if (name == null) throw new ArgumentNullException(nameof(name));
			else if (string.IsNullOrWhiteSpace(name))
				throw new ArgumentException("Parameter names cannot be empty or white space.", nameof(name));
			Contract.EndContractBlock();

			var p = new Param { Name = name, Type = type };
			if (value.HasValue) p.Value = value.Value;
			else p.Value = DBNull.Value;

			Params.Add(p);
			return (TThis)this;
		}

		/// <summary>
		/// Adds a parameter to the params list.
		/// </summary>
		/// <param name="name">The name of the parameter.</param>
		/// <param name="value">The value of the parameter.</param>
		/// <returns>This instance for use in method chaining.</returns>
		public TThis AddParam<T>(string name, T? value)
			where T : struct
		{
			if (name == null) throw new ArgumentNullException(nameof(name));
			Contract.EndContractBlock();

			var p = new Param { Name = name };
			if (value.HasValue) p.Value = value.Value;
			else p.Value = DBNull.Value;

			Params.Add(p);
			return (TThis)this;
		}

		/// <summary>
		/// Adds a parameter to the params list.
		/// </summary>
		/// <param name="name">The name of the parameter.</param>
		/// <returns>This instance for use in method chaining.</returns>
		public TThis AddParam(string name)
		{
			if (name == null) throw new ArgumentNullException(nameof(name));
			else if (string.IsNullOrWhiteSpace(name))
				throw new ArgumentException("Parameter names cannot be empty or white space.", nameof(name));
			Contract.EndContractBlock();

			Params.Add(new Param
			{
				Name = name
			});

			return (TThis)this;
		}


		/// <summary>
		/// Conditionally adds a parameter to the params list.
		/// </summary>
		/// <param name="condition">The condition to add the param by.  Only adds if true.</param>
		/// <param name="name">The name of the parameter.</param>
		/// <param name="value">The value of the parameter.</param>
		/// <returns>This instance for use in method chaining.</returns>
		public TThis AddParamIf<T>(bool condition, string name, T? value)
			where T : struct
			=> condition ? AddParam(name, value) : (TThis)this;

		/// <summary>
		/// Conditionally adds a parameter to the params list.
		/// </summary>
		/// <param name="condition">The condition to add the param by.  Only adds if true.</param>
		/// <param name="name">The name of the parameter.</param>
		/// <param name="value">The value of the parameter.</param>
		/// <returns>This instance for use in method chaining.</returns>
		public TThis AddParamIf(bool condition, string name, object value)
			=> condition ? AddParam(name, value) : (TThis)this;

		/// <summary>
		/// Conditionally adds a parameter to the params list.
		/// </summary>
		/// <param name="condition">The condition to add the param by.  Only adds if true.</param>
		/// <param name="name">The name of the parameter.</param>
		/// <param name="value">The value of the parameter.</param>
		/// <param name="type">The database type of the parameter.</param>
		/// <returns>This instance for use in method chaining.</returns>
		public TThis AddParamIf(bool condition, string name, object value, TDbType type)
			=> condition ? AddParam(name, value, type) : (TThis)this;

		/// <summary>
		/// Conditionally adds a parameter to the params list.
		/// </summary>
		/// <param name="condition">The condition to add the param by.  Only adds if true.</param>
		/// <param name="name">The name of the parameter.</param>
		/// <param name="value">The value of the parameter.</param>
		/// <param name="type">The database type of the parameter.</param>
		/// <returns>This instance for use in method chaining.</returns>
		public TThis AddParamIf<T>(bool condition, string name, T? value, TDbType type)
			where T : struct
			=> condition ? AddParam(name, value, type) : (TThis)this;

		/// <summary>
		/// Conditionally adds a parameter to the params list.
		/// </summary>
		/// <param name="condition">The condition to add the param by.  Only adds if true.</param>
		/// <param name="name">The name of the parameter.</param>
		/// <returns>This instance for use in method chaining.</returns>
		public TThis AddParamIf(bool condition, string name)
			=> condition ? AddParam(name) : (TThis)this;


		/// <summary>
		/// Sets the timeout value.
		/// </summary>
		/// <param name="seconds">The number of seconds to wait before the connection times out.</param>
		/// <returns>This instance for use in method chaining.</returns>
		public TThis SetTimeout(ushort seconds)
		{
			Timeout = seconds;
			return (TThis)this;
		}

		/// <summary>
		/// Handles adding the list of parameters to a new command.
		/// </summary>
		/// <param name="command">The command to add parameters to.</param>
		protected abstract void AddParams(TCommand command);

		/// <summary>
		/// Handles providing the connection for use with the command.
		/// </summary>
		/// <param name="action">The handler for use with the connection.</param>
		protected void UsingConnection(Action<TConnection, IDbTransaction> action)
		{
			if (action == null) throw new ArgumentNullException(nameof(action));
			Contract.EndContractBlock();

			if (Connection != null)
			{
				action(Connection, Transaction);
			}
			else
			{
				using (var conn = ConnectionFactory.Create())
				{
					action(conn, null);
				}
			}
		}

		/// <summary>
		/// Handles providing the connection for use with the command.
		/// </summary>
		/// <param name="action">The handler for use with the connection.</param>
		protected T UsingConnection<T>(Func<TConnection, IDbTransaction, T> action)
		{
			if (action == null) throw new ArgumentNullException(nameof(action));
			Contract.EndContractBlock();

			if (Connection != null)
			{
				return action(Connection, Transaction);
			}
			else
			{
				using (var conn = ConnectionFactory.Create())
				{
					return action(conn, null);
				}
			}
		}

		/// <summary>
		/// Handles providing the connection for use with the command.
		/// </summary>
		/// <param name="action">The handler for use with the connection.</param>
		protected async Task UsingConnectionAsync(Func<TConnection, IDbTransaction, Task> action)
		{
			if (action == null) throw new ArgumentNullException(nameof(action));
			Contract.EndContractBlock();
			if (Connection != null)
			{
				await action(Connection, Transaction);
			}
			else
			{
				using (var conn = ConnectionFactory.Create())
				{
					await action(conn, null);
				}
			}
		}

		/// <summary>
		/// Handles providing the connection for use with the command.
		/// </summary>
		/// <param name="action">The handler for use with the connection.</param>
		protected async Task<T> UsingConnectionAsync<T>(Func<TConnection, IDbTransaction, Task<T>> action)
		{
			if (action == null) throw new ArgumentNullException(nameof(action));
			Contract.EndContractBlock();

			if (Connection != null)
			{
				return await action(Connection, Transaction);
			}
			else
			{
				using (var conn = ConnectionFactory.Create())
				{
					return await action(conn, null);
				}
			}
		}

		/// <summary>
		/// Executes a reader on a command with a handler function.
		/// </summary>
		/// <param name="action">The handler function for each IDataRecord.</param>
		public void Execute(Action<TCommand> action)
		{
			if (action == null) throw new ArgumentNullException(nameof(action));
			Contract.EndContractBlock();

			UsingConnection((con, t) =>
			{
				var state = con.EnsureOpen(); // MUST occur before command creation as some DbCommands require it.
				try
				{
					using (var cmd = con.CreateCommand(Type, Command, Timeout))
					{
						if (!(cmd is TCommand c))
							throw new InvalidCastException($"Actual command type ({cmd.GetType()}) is not compatible with expected command type ({typeof(TCommand)}).");
						if (t != null)
							c.Transaction = t;

						AddParams(c);
						action(c);
					}
				}
				finally
				{
					if (state == ConnectionState.Closed) con.Close();
				}
			});
		}


		/// <summary>
		/// Executes a reader on a command with a transform function.
		/// </summary>
		/// <typeparam name="T">The return type of the transform function.</typeparam>
		/// <param name="transform">The transform function for each IDataRecord.</param>
		/// <returns>The result of the transform.</returns>
		public T Execute<T>(Func<TCommand, T> transform)
		{
			if (transform == null) throw new ArgumentNullException(nameof(transform));
			Contract.EndContractBlock();

			return UsingConnection((con, t) =>
			{
				var state = con.EnsureOpen(); // MUST occur before command creation as some DbCommands require it.
				try
				{
					using (var cmd = con.CreateCommand(Type, Command, Timeout))
					{
						if (!(cmd is TCommand c))
							throw new InvalidCastException($"Actual command type ({cmd.GetType()}) is not compatible with expected command type ({typeof(TCommand)}).");
						if (t != null)
							c.Transaction = t;
						AddParams(c);

						return transform(c);

					}
				}
				finally
				{
					if (state == ConnectionState.Closed) con.Close();
				}
			});

		}

		/// <summary>
		/// Calls ExecuteNonQuery on the underlying command but sets up a return parameter and returns that value.
		/// </summary>
		/// <returns>The value from the return parameter.</returns>
		public object ExecuteReturn()
			=> UsingConnection((con, t) =>
			{
				var state = con.EnsureOpen(); // MUST occur before command creation as some DbCommands require it.
				try
				{
					using (var cmd = con.CreateCommand(Type, Command, Timeout))
					{
						if (!(cmd is TCommand c))
							throw new InvalidCastException($"Actual command type ({cmd.GetType()}) is not compatible with expected command type ({typeof(TCommand)}).");
						if (t != null)
							c.Transaction = t;

						AddParams(c);
						var returnParameter = c.AddReturnParameter();

						c.ExecuteNonQuery();
						return returnParameter.Value;
					}
				}
				finally
				{
					if (state == ConnectionState.Closed) con.Close();
				}
			});

		/// <summary>
		/// Calls ExecuteNonQuery on the underlying command but sets up a return parameter and returns that value.
		/// </summary>
		/// <returns>The value from the return parameter.</returns>
		public T ExecuteReturn<T>()
			=> (T)ExecuteReturn();

		/// <summary>
		/// Executes a reader on a command with a handler function.
		/// </summary>
		/// <param name="handler">The handler function for the data reader.</param>
		/// <param name="behavior">The command behavior for once the command the reader is complete.</param>
		public void ExecuteReader(Action<IDataReader> handler, CommandBehavior behavior = CommandBehavior.Default)
		{
			if (Connection == null || Connection.State == ConnectionState.Closed) behavior = behavior | CommandBehavior.CloseConnection;
			Execute(command => command.ExecuteReader(handler, behavior));
		}

		/// <summary>
		/// Executes a reader on a command with a transform function.
		/// </summary>
		/// <typeparam name="T">The return type of the transform function.</typeparam>
		/// <param name="transform">The transform function for each IDataRecord.</param>
		/// <param name="behavior">The command behavior for once the command the reader is complete.</param>
		/// <returns>The result of the transform.</returns>
		public T ExecuteReader<T>(Func<IDataReader, T> transform, CommandBehavior behavior = CommandBehavior.Default)
		{
			if (Connection == null || Connection.State == ConnectionState.Closed) behavior = behavior | CommandBehavior.CloseConnection;
			return Execute(command => command.ExecuteReader(transform, behavior));
		}

		/// <summary>
		/// Iterates a reader on a command with a handler function.
		/// </summary>
		/// <param name="handler">The handler function for each IDataRecord.</param>
		public void IterateReader(Action<IDataRecord> handler)
			=> ExecuteReader(reader => reader.ForEach(handler), CommandBehavior.SingleResult);

		/// <summary>
		/// Iterates a reader on a command while the handler function returns true.
		/// </summary>
		/// <param name="handler">The handler function for each IDataRecord.</param>
		public void IterateReaderWhile(Func<IDataRecord, bool> handler)
			=> ExecuteReader(reader => reader.IterateWhile(handler), CommandBehavior.SingleResult);

		/// <summary>
		/// Executes a reader on a command with a transform function.
		/// </summary>
		/// <typeparam name="TEntity">The return type of the transform function applied to each record.</typeparam>
		/// <typeparam name="TResult">The type returned by the selector.</typeparam>
		/// <param name="transform">The transform function for each IDataRecord.</param>
		/// <param name="selector">Provides an IEnumerable&lt;TEntity&gt; to select individual results by.</param>
		/// <returns>The result of the transform.</returns>
		public TResult IterateReader<TEntity, TResult>(
			Func<IDataRecord, TEntity> transform,
			Func<IEnumerable<TEntity>, TResult> selector)
			=> ExecuteReader(reader => selector(reader.Iterate(transform)), CommandBehavior.SingleResult);

		/// <summary>
		/// Iterates an IDataReader and returns the first result through a transform function.  Throws if none.
		/// </summary>
		/// <typeparam name="T">The return type of the transform function.</typeparam>
		/// <param name="transform">The transform function to process each IDataRecord.</param>
		/// <returns>The value from the transform.</returns>
		public T First<T>(Func<IDataRecord, T> transform)
			=> ExecuteReader(reader => reader.Iterate(transform).First(), CommandBehavior.SingleRow | CommandBehavior.SingleResult);

		/// <summary>
		/// Iterates an IDataReader and returns the first result through a transform function.  Returns default(T) if none.
		/// </summary>
		/// <typeparam name="T">The return type of the transform function.</typeparam>
		/// <param name="transform">The transform function to process each IDataRecord.</param>
		/// <returns>The value from the transform.</returns>
		public T FirstOrDefault<T>(Func<IDataRecord, T> transform)
			=> ExecuteReader(reader => reader.Iterate(transform).FirstOrDefault(), CommandBehavior.SingleRow | CommandBehavior.SingleResult);

		/// <summary>
		/// Iterates a IDataReader and returns the first result through a transform function.  Throws if none or more than one entry.
		/// </summary>
		/// <typeparam name="T">The return type of the transform function.</typeparam>
		/// <param name="transform">The transform function to process each IDataRecord.</param>
		/// <returns>The value from the transform.</returns>
		public T Single<T>(Func<IDataRecord, T> transform)
			=> ExecuteReader(reader => reader.Iterate(transform).Single(), CommandBehavior.SingleResult);

		/// <summary>
		/// Iterates an IDataReader and returns the first result through a transform function.  Returns default(T) if none.  Throws if more than one entry.
		/// </summary>
		/// <typeparam name="T">The return type of the transform function.</typeparam>
		/// <param name="transform">The transform function to process each IDataRecord.</param>
		/// <returns>The value from the transform.</returns>
		public T SingleOrDefault<T>(Func<IDataRecord, T> transform)
			=> ExecuteReader(reader => reader.Iterate(transform).SingleOrDefault(), CommandBehavior.SingleResult);

		/// <summary>
		/// Iterates an IDataReader and returns the first number of results defined by the count.
		/// </summary>
		/// <typeparam name="T">The return type of the transform function.</typeparam>
		/// <param name="count">The maximum number of records to return.</param>
		/// <param name="transform">The transform function to process each IDataRecord.</param>
		/// <returns>The results from the transform limited by the take count.</returns>
		public List<T> Take<T>(int count, Func<IDataRecord, T> transform)
			=> ExecuteReader(reader => reader.Iterate(transform).Take(count).ToList(), CommandBehavior.SingleResult);

		/// <summary>
		/// Iterates an IDataReader and skips the first number of results defined by the count.
		/// </summary>
		/// <typeparam name="T">The return type of the transform function.</typeparam>
		/// <param name="count">The number of records to skip.</param>
		/// <param name="transform">The transform function to process each IDataRecord.</param>
		/// <returns>The results from the transform after the skip count.</returns>
		public List<T> Skip<T>(int count, Func<IDataRecord, T> transform)
			=> ExecuteReader(reader => reader.Iterate(transform).Skip(count).ToList(), CommandBehavior.SingleResult);

		/// <summary>
		/// Iterates an IDataReader and skips by the skip parameter returns the maximum remaining defined by the take parameter.
		/// </summary>
		/// <typeparam name="T">The return type of the transform function.</typeparam>
		/// <param name="skip">The number of entries to skip before starting to take results.</param>
		/// <param name="take">The maximum number of records to return.</param>
		/// <param name="transform">The transform function to process each IDataRecord.</param>
		/// <returns>The results from the skip, transform and take operation.</returns>
		public List<T> SkipThenTake<T>(int skip, int take, Func<IDataRecord, T> transform)
			=> ExecuteReader(reader => reader.Iterate(transform).Skip(skip).Take(take).ToList(), CommandBehavior.SingleResult);

		/// <summary>
		/// Calls ExecuteNonQuery on the underlying command.
		/// </summary>
		/// <returns>The integer response from the method. (Records updated.)</returns>
		public int ExecuteNonQuery()
			=> Execute(command => command.ExecuteNonQuery());

		/// <summary>
		/// Calls ExecuteScalar on the underlying command.
		/// </summary>
		/// <returns>The value returned from the method.</returns>
		public object ExecuteScalar()
			=> Execute(command => command.ExecuteScalar());

		/// <summary>
		/// Calls ExecuteScalar on the underlying command.
		/// </summary>
		/// <typeparam name="T">The type expected.</typeparam>
		/// <returns>The value returned from the method.</returns>
		public T ExecuteScalar<T>()
			=> (T)ExecuteScalar();

		/// <summary>
		/// Calls ExecuteScalar on the underlying command.
		/// </summary>
		/// <typeparam name="T">The type expected.</typeparam>
		/// <returns>The value returned from the method.</returns>
		public T ExecuteScalar<T>(Func<object, T> transform)
			=> transform(ExecuteScalar());

		/// <summary>
		/// Imports all data using an IDataReader into a DataTable.
		/// </summary>
		/// <returns>The resultant DataTable.</returns>
		public DataTable LoadTable()
			=> ExecuteReader(reader => reader.ToDataTable(), CommandBehavior.SequentialAccess | CommandBehavior.SingleResult);

		/// <summary>
		/// Loads all data from a command through an IDataReader into a DataTables.
		/// Calls .NextResult() to check for more results.
		/// </summary>
		/// <returns>The resultant list of DataTables.</returns>
		public List<DataTable> LoadTables()
			=> ExecuteReader(reader => reader.ToDataTables(), CommandBehavior.SequentialAccess);

		/// <summary>
		/// Converts all IDataRecords into a list using a transform function.
		/// </summary>
		/// <typeparam name="T">The expected return type.</typeparam>
		/// <param name="transform">The transform function.</param>
		/// <param name="behavior">The command behavior for once the command the reader is complete.</param>
		/// <returns>The list of transformed records.</returns>
		public List<T> ToList<T>(Func<IDataRecord, T> transform, CommandBehavior behavior = CommandBehavior.Default)
			=> ExecuteReader(reader => reader.Iterate(transform).ToList(), behavior | CommandBehavior.SingleResult);

		/// <summary>
		/// Converts all IDataRecords into an array using a transform function.
		/// </summary>
		/// <typeparam name="T">The expected return type.</typeparam>
		/// <param name="transform">The transform function.</param>
		/// <param name="behavior">The command behavior for once the command the reader is complete.</param>
		/// <returns>The array of transformed records.</returns>
		public T[] ToArray<T>(Func<IDataRecord, T> transform, CommandBehavior behavior = CommandBehavior.Default)
			=> ExecuteReader(reader => reader.Iterate(transform).ToArray(), behavior | CommandBehavior.SingleResult);

		/// <summary>
		/// Iterates all records within the first result set using an IDataReader and returns the results.
		/// DBNull values are left unchanged (retained).
		/// </summary>
		/// <returns>The QueryResult that contains all the results and the column mappings.</returns>
		public QueryResult<Queue<object[]>> Retrieve()
			=> ExecuteReader(reader => reader.Retrieve(), CommandBehavior.SequentialAccess | CommandBehavior.SingleResult);

		/// <summary>
		/// Iterates all records within the current result set using an IDataReader and returns the desired results.
		/// DBNull values are left unchanged (retained).
		/// </summary>
		/// <param name="ordinals">The ordinals to request from the reader for each record.</param>
		/// <returns>The QueryResult that contains all the results and the column mappings.</returns>
		public QueryResult<Queue<object[]>> Retrieve(IEnumerable<int> ordinals)
			=> ExecuteReader(reader => reader.Retrieve(ordinals));

		/// <summary>
		/// Iterates all records within the current result set using an IDataReader and returns the desired results.
		/// DBNull values are left unchanged (retained).
		/// </summary>
		/// <param name="n">The first ordinal to include in the request to the reader for each record.</param>
		/// <param name="others">The remaining ordinals to request from the reader for each record.</param>
		/// <returns>The QueryResult that contains all the results and the column mappings.</returns>
		public QueryResult<Queue<object[]>> Retrieve(int n, params int[] others)
			=> ExecuteReader(reader => reader.Retrieve(n, others));

		/// <summary>
		/// Iterates all records within the first result set using an IDataReader and returns the desired results as a list of Dictionaries containing only the specified column values.
		/// DBNull values are left unchanged (retained).
		/// </summary>
		/// <param name="columnNames">The column names to select.</param>
		/// <returns>The QueryResult that contains all the results and the column mappings.</returns>
		public QueryResult<Queue<object[]>> Retrieve(IEnumerable<string> columnNames)
			=> ExecuteReader(reader => reader.Retrieve(columnNames));

		/// <summary>
		/// Iterates all records within the current result set using an IDataReader and returns the desired results.
		/// DBNull values are left unchanged (retained).
		/// </summary>
		/// <param name="c">The first column name to include in the request to the reader for each record.</param>
		/// <param name="others">The remaining column names to request from the reader for each record.</param>
		/// <returns>The QueryResult that contains all the results and the column mappings.</returns>
		public QueryResult<Queue<object[]>> Retrieve(string c, params string[] others)
			=> ExecuteReader(reader => reader.Retrieve(c, others));

		/// <summary>
		/// Iterates each record and attempts to map the fields to type T.
		/// Data is temporarily stored (buffered in entirety) in a queue of dictionaries before applying the transform for each iteration.
		/// </summary>
		/// <typeparam name="T">The model type to map the values to (using reflection).</typeparam>
		/// <param name="fieldMappingOverrides">An optional override map of field names to column names where the keys are the property names, and values are the column names.</param>
		/// <returns>The enumerable to pull the transformed results from.</returns>
		public IEnumerable<T> Results<T>(IEnumerable<KeyValuePair<string, string>> fieldMappingOverrides)
			where T : new()
			=> ExecuteReader(reader => reader.Results<T>(fieldMappingOverrides));

		/// <summary>
		/// Iterates each record and attempts to map the fields to type T.
		/// Data is temporarily stored (buffered in entirety) in a queue of dictionaries before applying the transform for each iteration.
		/// </summary>
		/// <typeparam name="T">The model type to map the values to (using reflection).</typeparam>
		/// <param name="fieldMappingOverrides">An optional override map of field names to column names where the keys are the property names, and values are the column names.</param>
		/// <returns>The enumerable to pull the transformed results from.</returns>
		public IEnumerable<T> Results<T>(IEnumerable<(string Field, string Column)> fieldMappingOverrides)
			where T : new()
			=> ExecuteReader(reader => reader.Results<T>(fieldMappingOverrides));

		/// <summary>
		/// Reads the first column from every record and returns the results as a list..
		/// DBNull values are converted to null.
		/// </summary>
		/// <returns>The list of transformed records.</returns>
		public IEnumerable<object> FirstOrdinalResults()
			=> ExecuteReader(reader => reader.FirstOrdinalResults(), CommandBehavior.SequentialAccess);

		/// <summary>
		/// Reads the first column from every record..
		/// DBNull values are converted to null.
		/// </summary>
		/// <returns>The enumerable of casted values.</returns>
		public IEnumerable<T0> FirstOrdinalResults<T0>()
			=> ExecuteReader(reader => reader.FirstOrdinalResults<T0>(), CommandBehavior.SequentialAccess);

		/// <summary>
		/// Iterates each record and attempts to map the fields to type T.
		/// Data is temporarily stored (buffered in entirety) in a queue of dictionaries before applying the transform for each iteration.
		/// </summary>
		/// <typeparam name="T">The model type to map the values to (using reflection).</typeparam>
		/// <param name="fieldMappingOverrides">An optional override map of field names to column names where the keys are the property names, and values are the column names.</param>
		/// <returns>The enumerable to pull the transformed results from.</returns>
		public IEnumerable<T> Results<T>(params (string Field, string Column)[] fieldMappingOverrides)
			where T : new()
			=> ExecuteReader(reader => reader.Results<T>(fieldMappingOverrides));

		/// <summary>
		/// Posts all records to a target block using the transform function.
		/// Stops if the target block rejects.
		/// </summary>
		/// <typeparam name="T">The expected type.</typeparam>
		/// <param name="transform">The transform function.</param>
		/// <param name="target">The target block to receive the results (to be posted to).</param>
		public void ToTargetBlock<T>(ITargetBlock<T> target, Func<IDataRecord, T> transform)
			=> IterateReaderWhile(r => target.Post(transform(r)));

		/// <summary>
		/// Returns a buffer block that will contain the results.
		/// </summary>
		/// <typeparam name="T">The expected type.</typeparam>
		/// <param name="transform">The transform function.</param>
		/// <param name="synchronousExecution">By default the command is deferred.
		/// If set to true, the command runs synchronously and all data is acquired before the method returns.
		/// If set to false (default) the data is received asynchronously (deferred: data will be subsequently posted) and the source block (transform) can be completed early.</param>
		/// <returns>The buffer block that will contain the results.</returns>
		public IReceivableSourceBlock<T> AsSourceBlock<T>(
			Func<IDataRecord, T> transform,
			bool synchronousExecution = false)
		{
			if (transform == null) throw new ArgumentNullException(nameof(transform));
			Contract.EndContractBlock();

			var source = new BufferBlock<T>();
			void I()
			{
				ToTargetBlock(source, transform);
				source.Complete();
			}

			if (synchronousExecution) I();
			else Task.Run(I);
			return source;
		}

		/// <summary>
		/// Provides a transform block as the source of records.
		/// </summary>
		/// <typeparam name="T">The model type to map the values to (using reflection).</typeparam>
		/// <param name="fieldMappingOverrides">An override map of field names to column names where the keys are the property names, and values are the column names.</param>
		/// <param name="synchronousExecution">By default the command is deferred.
		/// If set to true, the command runs synchronously and all data is acquired before the method returns.
		/// If set to false (default) the data is received asynchronously (data will be subsequently posted) and the source block (transform) can be completed early.</param>
		/// <param name="options">The optional ExecutionDataflowBlockOptions to use with the source.</param>
		/// <returns>A transform block that is receiving the results.</returns>
		public IReceivableSourceBlock<T> AsSourceBlock<T>(
			IEnumerable<(string Field, string Column)> fieldMappingOverrides,
			bool synchronousExecution = false,
			ExecutionDataflowBlockOptions options = null)
		   where T : new()
		{
			var x = new Transformer<T>(fieldMappingOverrides);
			var cn = x.ColumnNames;
			var q = x.Results(out var deferred, options);

			void I() => ExecuteReader(reader =>
			{
				// Ignores fields that don't match.
				// ReSharper disable once PossibleMultipleEnumeration
				var columns = reader.GetMatchingOrdinals(cn, true);

				var ordinalValues = columns.Select(c => c.Ordinal).ToArray();
				deferred(new QueryResult<IEnumerable<object[]>>(
					ordinalValues,
					columns.Select(c => c.Name).ToArray(),
					reader.AsEnumerable(ordinalValues)));

			});

			if (synchronousExecution) I();
			else Task.Run(I);
			return q;
		}

		/// <summary>
		/// Provides a transform block as the source of records.
		/// </summary>
		/// <typeparam name="T">The model type to map the values to (using reflection).</typeparam>
		/// <param name="fieldMappingOverrides">An override map of field names to column names where the keys are the property names, and values are the column names.</param>
		/// <param name="synchronousExecution">By default the command is deferred.
		/// If set to true, the command runs synchronously and all data is acquired before the method returns.
		/// If set to false (default) the data is received asynchronously (data will be subsequently posted) and the source block (transform) can be completed early.</param>
		/// <param name="options">The optional ExecutionDataflowBlockOptions to use with the source.</param>
		/// <returns>A transform block that is receiving the results.</returns>
		public IReceivableSourceBlock<T> AsSourceBlock<T>(
			IEnumerable<KeyValuePair<string, string>> fieldMappingOverrides,
			bool synchronousExecution = false,
			ExecutionDataflowBlockOptions options = null)
			where T : new()
			=> AsSourceBlock<T>(fieldMappingOverrides?.Select(kvp => (kvp.Key, kvp.Value)), synchronousExecution, options);

		/// <summary>
		/// Provides a transform block as the source of records.
		/// </summary>
		/// <typeparam name="T">The model type to map the values to (using reflection).</typeparam>
		/// <param name="fieldMappingOverrides">An override map of field names to column names where the keys are the property names, and values are the column names.</param>
		/// <returns>A transform block that is receiving the results.</returns>
		public IReceivableSourceBlock<T> AsSourceBlock<T>(params (string Field, string Column)[] fieldMappingOverrides)
			where T : new()
			=> AsSourceBlock<T>(fieldMappingOverrides as IEnumerable<(string Field, string Column)>);

	}
}
